---
layout: algorithm
title: 2226. 每个小孩最多能分到多少糖果
author: crescent
categories:
  - algorithm
tags:
  - 287场周赛
  - algorithm
  - leetcode
  - 中等
  - 二分
date: 2022-04-03 20:31:30
---
# 2226. 每个小孩最多能分到多少糖果
**难度：中等**  
链接：https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/
## 题目
给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。

另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。

返回每个小孩可以拿走的 最大糖果数目 。

## 示例
输入：candies = [5,8,6], k = 3
输出：5
解释：可以将 candies[1] 分成大小分别为 5 和 3 的两堆，然后把 candies[2] 分成大小分别为 5 和 1 的两堆。现在就有五堆大小分别为 5、5、3、5 和 1 的糖果。可以把 3 堆大小为 5 的糖果分给 3 个小孩。可以证明无法让每个小孩得到超过 5 颗糖果。

## 提示
+ 1 <= candies.length <= 105
+ 1 <= candies[i] <= 107
+ 1 <= k <= 1012

## 思路
**方法**  
这题的判断条件很简单，输入每个孩子可以拿走的最大糖果数，就能根据糖果数组直接算出能分给的小孩数。然后就用二分缩小数据范围即可。

## 解答
``` python
class Solution:
    def maximumCandies(self, candies: List[int], k: int) -> int:
        def enouth_people(candies,num):
            return sum([candie//num for candie in candies])
        sum_c = sum(candies)
        max_avg_candies = sum_c // k
        if max_avg_candies == 0:
            return 0
        # 二分
        max_c = max_avg_candies
        min_c = 0
        while min_c < max_c:
            mid_c = (min_c + max_c) // 2 + 1
            if enouth_people(candies,mid_c)<k:
                max_c = mid_c - 1
            else:# 如果当前c不满足，说明要更大
                min_c = mid_c
        return min_c
```